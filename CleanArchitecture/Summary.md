## 第一章 設計とアーキテクチャ

- プロダクトが成長する毎にコード当たりのコストは増加する。
- コストを下げるためにも設計が重要。
- ソフトウェアアーキテクチャと向き合うためには優れたソフトウェアアーキテクチャとは何かを知る必要がある。

## 第二章 二つの価値のお話

- ソフトウェアシステムは「振る舞い」と「構造」の二つの価値を持つ。

  - 振る舞い
    - マシンへ振る舞いを与えるものがソフトウェア
  - 構造
    - 簡単に変更できるような構造を持たせること

- 完璧に動作するが変更できないプログラムと動作しないが変更が簡単なプログラムはどちらが良いのか。
  - 変更が容易であれば、動作しないプログラムでも修正が可能という考え方もある。
  - ビジネス的な観点でいえば、完璧な動作を求めがちであるが、プログラマとしては校舎の考えを持つべき
- 振る舞いは緊急性が高く、構造は重要性が高い。
  - 両者のバランスを評価することがソフトウェア開発者の存在意義なのではないか。
  - 構造を司るのがアーキテクチャ

## 第三章 パラダイムの概要

- 本書で紹介するパラダイムは以下の通り
  - 構造化プログラミング
    - 直接的な制御の移行に規律を課すもの
  - オブジェクト指向プログラミング
    - 間接的な制御の移行に規律を課すもの
  - 関数型プログラミング
    - 代入に規律を課すもの
- これらのパラダイムはプログラマに制約を課すものである。何をすべきべきでないかを示すもの。

## 第四章 構造化プログラミング

- 構造化プログラミングの価値を高めるためには、半鐘可能なプログラミングの単位を作成することが重要。
- アーキテクチャレベルにおいても、機能分割がベストプラクティスと考えられているのは同様の理由からである。

## 第五章 オブジェクト指向プログラミング

- オブジェクト指向とは何か
  - データと関数の組み合わせ
  - 現実の世界をモデル化する
  - カプセル化、継承、ポリモーフィズム
- カプセル化とは
  - データと関数を一つのコンポーネントに閉じ込め、ブラックボックス化させること
    - オブジェクト指向はカプセル化はしているものの強制的なものはなく、依存もしていない。結果、実装によってはカプセル化が崩れることもある。
- 継承とは
  - あるクラスが特性を引き継いで新たなクラスとして定義されること
- ポリモーフィズムとは
  - 同じインターフェースを持つ異なるクラスのオブジェクトを同じように扱うこと
  - 依存関係を減らすことで、変更に強いプログラムを作成することができる。
- オブジェクト指向はポリモーフィズムを使用することで、システムにあるすべてのソースコードの依存関係を絶対的に制御する能力

## 第六章 関数型プログラミング

- 関数型プログラミングにおける変数は変更不可能である。
- 関数型プログラミングは代入に規律を課すもの
  - 変数を不変性にすることで、プログラムの振る舞いを予測しやすくなる。
  - 競合やデッドロックを回避することができる。
- 可変コンポーネントと不変コンポーネントを分離することで、プログラムの複雑性を減らすことができる。
- プログラミングにおいて状態を管理することは難しい。状態を管理することが難しいのは、状態が変化することで、プログラムの振る舞いが変化するため。

# 設計の原則

- SOLID 原則を守る
  - SOLID の目的は
    - 変更に強い
    - 理解しやすい
    - コンポーネントの基盤として、多くのソフトウェアシステムで利用できる
  - SOLID の原則
    - 単一責任の原則
      - 一つのクラスは一つの責務を持つべき
      - オープン・クローズドの原則
        - クラスは拡張に対して開かれ、修正に対して閉じられているべき
      - リスコフの置換原則
        - サブタイプはその基底型と置換可能でなければならない
      - インターフェース分離の原則
        - クライアントは利用しないメソッドに依存すべきではない
      - 依存性逆転の原則
        - 高レベルのモジュールは低レベルのモジュールに依存すべきではない。両方が抽象に依存すべきである。

## 単一責任の原則

- 色々な理解のされ方があるが代表的なものは下記
  - モジュールを変更する理由はたった一つだけであるべきである。
  - モジュールはたった一つのアクターに対して責務を負うべきである。
- クラスを使用する人は、一人（責任範囲が固定されているという意味で）であるべき。
- クラスの責任範囲の分割とコードの再利用のバランスを取ることが重要。
  - 具体的な解決方法は下記
    - Facade パターン
      - Facade パターンは、複数のクラスを一つのクラスにまとめることで、クラスの責任範囲を明確にすることができる。

## オープンクローズドの原則

- ソフトウェアの構成要素は拡張に対して開かれ、修正に対して閉じられているべき。
  - ソフトウェアの修正は既存の成果物を変更せずに拡張できるようにするべきである。
  - 各クラスはコンポーネントごとに整理されるべきで、各コンポーネントの依存は単方向であるべき。
  - コンポーネントの役割は以下 4 つに整理できる
    - Controller
      - ユーザーからの入力を受け取り、ユースケースを実行する指示を出す
      - ドメインモデルはここで管理する
    - Interactor
      - 受け取った指示を元にユースケースを実行する
      - ドメインモデルは管理しない。システム内のアプリの基本処理を管理する
    - Database Gateway
      - データベースとのやり取りを行う
      - Presenter
        - 主にデータ加工などを行うその結果を出力する。
  - 各コンポーネントは独立しているべきで、他のコンポーネントに依存してはならない。
    - 特に Controller と Interactor は独立させるように設計することが重要。

## リスコフの置換原則

- リスコフの置換原則とは、サブタイプはその基底型と置換可能でなければならないという原則。
  - サブクラスは基底クラスの振る舞いを変更することなく、基底クラスの代わりに使用できるべきである。
  - この原則を守ることで、プログラムの拡張性を高めることができる。
  - この原則を守るためには、基底クラスとサブクラスの関係をよく理解することが重要。

## インターフェース分離の原則

- 複数のソースが同じメソッドや、クラスを参照しているとき、そのクラスの使用者同氏は依存関係にあると言える。
  - そのクラスが変更されたとき、仕様ソースは際コンパイルを行う必要があるが、インターフェースを実装させることで再コンパイルを防ぎ、依存関係を減らすことができる。
  - この実装が必要かどうかは言語による。
  - python 等の動的型付け言語では、インターフェースを実装する必要がない。

## 依存関係逆転の原則

最も柔軟なシステムはソースコードの依存関係が抽象だけを参照しているもの。

## コンポーネントの凝集性

- どのクラスをどのコンポーネントに含めればよいのかの判断基準となる原則は下記

  - 再利用・リリース等価の原則
  - 閉鎖性共通の原則
  - 全再利用の原則

- 再利用・リリース等価の原則（REP）
  - 再利用の単位とリリースの単位は等価であるべき
  - コンポーネントに含まれるクラスはすべて再利用されるか、すべてが再利用できないかのどちらかにすべき
  - コンポーネントは一貫するテーマや目的に沿っているべき
- 閉鎖性共通の原則（CCP）
  - 同じ理由、同じタイミングで変更されるクラスをコンポーネントにまとめること
  - コンポーネントを変更する理由が複数あるべきではない
  - 再利用性より保守性の方がぶっちゃけ大事
- 全再利用の原則（CRP）

  - 不要なものには依存しないこと
  - コンポーネントのユーザーに対して、実際には使わないもの経の依存を強要してはいけない。
    - 1 つのコンポーネントに含まれるすべてのクラスに依存するようにしておきたい。
    - インターフェース分離の原則を一般化させたもの。

- それぞれコンポーネントを作成するモチベーションが異なる。
- チームごとに落としどころを見つけて落とし込む必要がある。
