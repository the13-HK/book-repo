## 第一章 設計とアーキテクチャ

- プロダクトが成長する毎にコード当たりのコストは増加する。
- コストを下げるためにも設計が重要。
- ソフトウェアアーキテクチャと向き合うためには優れたソフトウェアアーキテクチャとは何かを知る必要がある。

## 第二章 二つの価値のお話

- ソフトウェアシステムは「振る舞い」と「構造」の二つの価値を持つ。

  - 振る舞い
    - マシンへ振る舞いを与えるものがソフトウェア
  - 構造
    - 簡単に変更できるような構造を持たせること

- 完璧に動作するが変更できないプログラムと動作しないが変更が簡単なプログラムはどちらが良いのか。
  - 変更が容易であれば、動作しないプログラムでも修正が可能という考え方もある。
  - ビジネス的な観点でいえば、完璧な動作を求めがちであるが、プログラマとしては校舎の考えを持つべき
- 振る舞いは緊急性が高く、構造は重要性が高い。
  - 両者のバランスを評価することがソフトウェア開発者の存在意義なのではないか。
  - 構造を司るのがアーキテクチャ

## 第三章 パラダイムの概要

- 本書で紹介するパラダイムは以下の通り
  - 構造化プログラミング
    - 直接的な制御の移行に規律を課すもの
  - オブジェクト指向プログラミング
    - 間接的な制御の移行に規律を課すもの
  - 関数型プログラミング
    - 代入に規律を課すもの
- これらのパラダイムはプログラマに制約を課すものである。何をすべきべきでないかを示すもの。

## 第四章 構造化プログラミング

- 構造化プログラミングの価値を高めるためには、半鐘可能なプログラミングの単位を作成することが重要。
- アーキテクチャレベルにおいても、機能分割がベストプラクティスと考えられているのは同様の理由からである。

## 第五章 オブジェクト指向プログラミング

- オブジェクト指向とは何か
  - データと関数の組み合わせ
  - 現実の世界をモデル化する
  - カプセル化、継承、ポリモーフィズム
- カプセル化とは
  - データと関数を一つのコンポーネントに閉じ込め、ブラックボックス化させること
    - オブジェクト指向はカプセル化はしているものの強制的なものはなく、依存もしていない。結果、実装によってはカプセル化が崩れることもある。
- 継承とは
  - あるクラスが特性を引き継いで新たなクラスとして定義されること
- ポリモーフィズムとは
  - 同じインターフェースを持つ異なるクラスのオブジェクトを同じように扱うこと
  - 依存関係を減らすことで、変更に強いプログラムを作成することができる。
- オブジェクト指向はポリモーフィズムを使用することで、システムにあるすべてのソースコードの依存関係を絶対的に制御する能力

## 第六章 関数型プログラミング

- 関数型プログラミングにおける変数は変更不可能である。
- 関数型プログラミングは代入に規律を課すもの
  - 変数を不変性にすることで、プログラムの振る舞いを予測しやすくなる。
  - 競合やデッドロックを回避することができる。
- 可変コンポーネントと不変コンポーネントを分離することで、プログラムの複雑性を減らすことができる。
- プログラミングにおいて状態を管理することは難しい。状態を管理することが難しいのは、状態が変化することで、プログラムの振る舞いが変化するため。

# 設計の原則

- SOLID 原則を守る
  - SOLID の目的は
    - 変更に強い
    - 理解しやすい
    - コンポーネントの基盤として、多くのソフトウェアシステムで利用できる
  - SOLID の原則
    - 単一責任の原則
      - 一つのクラスは一つの責務を持つべき
      - オープン・クローズドの原則
        - クラスは拡張に対して開かれ、修正に対して閉じられているべき
      - リスコフの置換原則
        - サブタイプはその基底型と置換可能でなければならない
      - インターフェース分離の原則
        - クライアントは利用しないメソッドに依存すべきではない
      - 依存性逆転の原則
        - 高レベルのモジュールは低レベルのモジュールに依存すべきではない。両方が抽象に依存すべきである。

## 単一責任の原則
