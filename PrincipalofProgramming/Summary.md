- principle3.29 移行の内容のメモ書き

### 7 つの設計原理

コードレビューにおけるチャック観点は 7 つ
コードを書く時にも参照できる

- 単純原理
  - 単純なコードを書くように心がける
  - 直観的に自然なコードを書くで、コードの理解が容易になる
- 同型原理
  - 同じようなコードを書くことを心掛ける
  - 例外を作らない
- 対象原理
  - 形の対称性にこだわる
  - コード設計時の考慮もれを構造的に防ぐことが出来る
    - set/get 等
- 階層原理
  - 構造が階層であることにこだわる
    - 主従関係
    - 前後関係
    - 本末関係
  - 抽象改造構造を意識する
  - 上位レベルが下位レベルを知っているが、下位レベルが上位レベルを知らない
- 線形原理
  - 処理の流れが直線的であることにこだわる
    - スイッチでの分岐を避ける
    - 状態の変化を避ける
- 明証原理
  - ロジックが明確であることにこだわる
    - ロジックが明確であることで、コードの理解が容易になる
    - 不確実性を排除することで可読性が上がる
- 安全原理
  - 必然性のないことを排除する
    - これはありえないなという分岐のコードは書かない

### UNIX 思想

UNIX 思想は公式な方法論ではないがボトムアップ的に培われた文化、それに準じた設計思想を持つことで、コードの品質を向上させることが出来る。
対象の原則は全部で 17 つ

- モジュール化の原則
  - 複雑さを回避するためにはクリーンなインターフェースで結びつけられたシンプルなモジュールを作成することが大事
  - モジュール関係が簡潔になるようする
  - クリーンなインターフェース=モジュールの入り口を狭くするということ
- 明確性の原則
  - コードは明確になるように書く。
- 組み立て部品の原則
  - 入力としてデータストリームを受け付け別のデータストリームとして出力する形で作成する
  - ソフトウェアはフィルタとして組み立て部品のようにふるまうことが出来る。
- 分離の原則
  - ポリシーとメカニズムを分ける
  - ポリシー
    - ソフトウェアの前提に依存する部分
      - ビジネスロジックや　ユーザーインタフェース等
  - メカニズム
    - ポリシーに依存しない独立した部分
  - フロントエンドとバックエンドの分離
- 単純性の原則
  - シンプルにコードを書け。技術を誇示するな。
- 倹約の原則
  - 大きなコード（複雑度が高い）を書かない
- 透明性の原則
  - ソフトウェアの動作を外からわかりやすく見えるように設計する
- 安定性の原則
  - 堅牢なコードを書く
- 表現性の原則
  - コードにおける情報の表現方法は、ロジックではなくデータに寄せる（？）
    - 複雑さはデータに寄せ、ロジックはシンプルにする
- 驚き最小の原則
  - 読む人が予想しやすいコードにする
  - 学習コストが下がる
- 沈黙の原則
  - 表示よち小限に抑える。情報は必要な時にだけ表示する
- 修復の原則
  - エラー時に処理が継続するのは避ける
- 経済性の原則
  - プログラマに投資しろ！
- 生成の原則
  - コードを書くためにコードを書く。
  - コードジェネレータを作る。
- 最適化の原則
  - 速いより、正しいコードを書く
  - 正しくしてから速くする。
- 多様性の原則
  - 多様性を認め、より良いやり方を模索する
- 拡張性の原則
  - 拡張できる設計にする。
  - ソフトウェアが成長することを前提に設計する
  - プラガブル（接続可能）な設計にする

### UNIX の哲学

UNIX の背後にある設計の哲学は以下 9 個の定理にまとめられている。

- 小は美なり
  - 小さいソフトウェアにすることによって理解が容易になり、保守が容易になる。
  - 他のソフトウェアと組み合わせしやすい
- レバレッジ・ソフトウェア
  - 既存のソフトウェアを再利用、組み合わせることで増幅させるようなソフトウェアを作成する
  - 単機能で単価値に集中した小さなソフトウェアを作成する
- 1 つ 1 仕事
  - ソフトウェア一つに責任を一つ持たせることでピュアなソフトウェアにする
- シェルスクリプト活用
  - シェルスクリプトを活用することで梃子の効果と移植性を高める。
  - シェルスクリプトをグルー言語として使う
- 即行プロトタイプ
  - 出来るだけ早くプロトタイプを作成し、試行錯誤を行う
  - 試行錯誤無しで良いものは作成できない
- 対話インターフェース回避
  - 拘束的ユーザーインタフェースは避ける
  - 一旦ソフトウェアを起動すると、それが終了するまでコマンドインタプリタとの対話が出来なくなることを拘束的、と呼んでいる
- 効率性より移植性
  - 他のプラットフォームに移植しやすいようにする
  - 移植性と開発効率性は二律背反だが、移植性を重視させ、ることでソフトウェアの価値を継続させることを優先させる。
  - ハードウェアに依存しないコードを書くことが大事
    - Docker は大事
- フィルタ化
  - ソフトウェアはフィルタとして設計する
  - ソフトウェアはデータを処理することであり、生成することではない。
  - データの入出力が発生すること前提で設計を行う。
- データはテキスト
  - データはテキストファイルに保存するようにする。
  - テキストファイルが移植性の面で最強
  - 人間でもデータが直ちに確認できる
  - ツールやコマンドも扱いやすい形式

## 第 4 章 視点~プログラマの観る角度~
